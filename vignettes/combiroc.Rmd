---
title: "Quick guide to CombiROC"
subtitle: |
  | Finding optimal combinations of markers from omics data
author: "Ivan Ferrari, Riccardo L. Rossi"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    toc: true 
    df_print: paged
vignette: >
  %\VignetteIndexEntry{Quick guide to CombiROC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
#library(httr)
#knitr::opts_chunk$set(comment = "#>", collapse = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
library(combiroc)
```

# Summary {#top}

Powerful biomarkers are important tools in diagnostic, clinical and research settings. In the area of diagnostic medicine, a biomarker is often used as a tool to identify subjects with a disease, or at high risk of developing a disease. Moreover, it can be used to foresee the more likely outcome of the disease, monitor its progression and predict the response to a given therapy. Diagnostic accuracy can be improved considerably by combining multiple markers, whose performance in identifying diseased subjects is usually assessed via receiver operating characteristic (ROC) curves. The CombiROC tool was originally designed as an easy to use R-Shiny web application to determine optimal combinations of markers from diverse complex omics data ( [Mazzara et al. 2017](https://www.nature.com/articles/srep45477) ); such an implementation is easy to use but has limited features and limitations arise from the machine it is deployed on. The CombiROC _package_ is the natural evolution of the CombiROC tool and it allows the researcher/analyst to freely use the method and further build on it. 

# Standard CombiROC workflow

The aim of this document is to show the whole CombiROC workflow to get you up and running as quickly as possible with this package. To do so we're going to use the proteomic dataset from [Zingaretti et al. 2012](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518104/) containing multi-marker signatures for Autoimmune Hepatitis (AIH) for samples clinically diagnosed as “abnormal” (class A) or "normal" (class B). The scope of the workflow is to first find the markers combinations, then to assess their performance in classifying samples of the dataset.

__Note:__ if you use combiroc in your research, please cite:

> Mazzara S., Rossi R.L., Grifantini R., Donizetti S., Abrignani L., Bombaci M. (2017) CombiROC: an interactive web tool for selecting accurate marker combinations of omics data. _Scientific Reports_, __7__:45477. [10.1038/srep45477](https://doi.org/10.1038/srep45477)  

## Required data format

The dataset to be analysed should be in text format, which can be separated by commas, tabs or semicolons. Format of the columns should be the following:

- The 1st column must contain unique patient/sample IDs.
- The 2nd column must contain the class to which each sample belongs.
- The classes must be exactly TWO and they must be written in character format (i.e. "A" and "B").
- From the 3rd column on, the dataset must contain numerical values that represent the signal corresponding to the markers abundance in each sample (marker-related columns).
- The header for marker-related columns can be called 'Marker1, Marker2, Marker3, ...' or can be called directly with the gene/protein name. __Please note__ that "-" (dash) is __not__ allowed in the column names

## Data loading

The `load_data()` function uses a customized **read.table()** function that checks the conformity of the dataset format. If all the checks are passed, marker-related columns are reordered alphabetically, depending on marker names (this is necessary for a proper computation of combinations), and it imposes "Class" as the name of the second column. The loaded dataset is here assigned to the "*data*" object.
```{r, eval=FALSE}
data <- load_data("../data/demo_data.csv", sep=';')
head(data)
```
```{r, echo=FALSE}
data <- load_data("../data/demo_data.csv", sep=';')
head(data)
```
The AIH demonstrative dataset is preloaded in the package and can be directly called typing `demo_data`. 

## Exploring the data

It is usually a good thing to visually explore your data with at least a few plots. Box plots are a nice option to observe the distribution of measurements in each sample. The user can plot the data as she/he wishes using the preferred function: since data for CombiROC are required to be in _wide_ (_untidy_) format, they cannot directly used with the widely used `ggplot()` function. Either the user is free to make the data longer (tidy) for the sole purpose of plotting or the package's `CombiROC_long()` function can be used for this purpose, which is designed to wrap `tidyr::pivot_longer()`function, and it's used to reshape the data in long format. Data in long format are required for the plotting functions of the package. 

The __data__ object in wide format is thus transformed into the reshaped long format __data_long__ object

```{r}
data_long <- CombiROC_long(data)
data_long
```


## Markers distribution overview

Since the target of the analysis is the identification of marker combinations capable to correctly classify samples, the user should choose a signal threshold to define the positivity for a given marker/combination. This threshold should:

- Positively select most samples belonging to the case class ("A" in this case), which values must be above the signal threshold.
- Negatively select most control samples ("B"), which values must be below the signal threshold. 

Usually this threshold is suggested by the guidelines of the kit used for the analysis (e.g. mean of buffer signal + n standard deviations). However, it is a good practice to always check the distribution of signal intensity of the dataset. To help the user with this operation, the `markers_distribution()` have been implemented. This function takes as input data in long format ( __data_long__ ), and returns a named list (here assigned to the __distr__ object). Specific warnings are ususlly triggered with this command remembering the users a few default parameters that are in place during the computation. 

```{r}
distr <- markers_distribution(data_long, case_class = 'A', y_lim = 0.0015, x_lim = 3000, signalthr_prediction = TRUE, min_SE = 40, min_SP = 80, boxplot_lim = 2000)
```

The __distr__ object contains the following elements: 

- a Boxplot distribution
- a ROC curve
- the curve's coordinates
- a density plot
- a summary. 

All this information can be plotted/displayed individually.  

### Distribution via boxplot 

The __Boxplot__ shows the distribution of each marker values for both classes:
```{r, boxplot}
distr$Boxplot
```

### The ROC curve for all markers and its coordinates

The __ROC__ curve shows how many real positive samples would be found positive (sensitivity, or SE) and how many real negative samples would be found negative (specificity, or SP) in function of signal threshold. NB: these SE and SP are refereed to the signal intensity threshold considering _all_ the markers together; they are _not_ the SE and SP of a single marker/combination computed by the `SE_SP()` command further discussed in the **Sensitivity and specificity** paragraph.
```{r, ROC}
distr$ROC
```

The __Coord__ is a dataframe that contains the coordinates of the above described "ROC" (threshold, SP and SE) that have at least a min SE (40 by default) and a min SP (80 by default). These limits can be set manually by specifying  min_SE and min_SP. The Youden index is also computed: this is the Youden's J statistic capturing the performance of a dichotomous diagnostic test, with higher values for better performance (note that Youden index is computed here as $J = SE + SP$, but can be found elsewhere calculated as $J = SE + SP -1$, with lower and upper limits being 0 and 1 respectively).
```{r, coord1}
head(distr$Coord, n=10)
```

### The density plot and summary for signals

The __Density_plot__ shows the distribution of the signal intensity values for both the classes. In addition, the function allows the user to set both the y_lim and x_lim values to provide a better visualization.
```{r, density}
distr$Density_plot
```

Finally, the __Density_summary__ displays a few summary statistics of the density plot.
```{r, summary}
distr$Density_summary
```

In case of lack of a priori known threshold the user can set set signalthr_prediction= TRUE. In this way the function provides a "suggested signal threshold" that corresponds to the median of the signal threshold values (in "Coord") at which SE/SP are greater or equal to their set minimal values (min_SE and min_SP), and it adds this threshold on the "Density_plot" object as a dashed black line. The use of the median allows to pick a threshold whose SE/SP are not too close to the limits (min_SE and min_SP), but it is recommended to always inspect "Coord" and choose the most appropriate signal threshold by considering SP, SE and Youden index.

## Combinatorial analysis

`Combi()` function computes the marker combinations and counts their corresponding positive samples for each class (once thresholds are selected). A sample, to be considered positive for a given combination, must have a value higher than a given signal threshold (signalthr) for at least a given number of markers composing that combination (combithr). In this case `signalthr` is set at 450 while `combithr` is set at 1, in order to reproduce both the results reported in [Mazzara et. al 2017](https://www.nature.com/articles/srep45477) (CombiROC paper) and also the tutorial of the web app with default thresholds. 

As discussed before, `signalthr` should be set depending on the guidelines of the kit used for the analysis or by an accurate inspection of signal intensity distribution (see **Markers distribution overview** section). In this specific case 450 is the mean of the intensity of buffer + 3 standard deviation (see [Bombaci & Rossi 2019](https://link.springer.com/protocol/10.1007%2F978-1-4939-9164-8_16)).
In case of lack of guidelines, it's recommended the inspection of data distribution (see `markers_distribution()`). 

`combithr`, instead, should be set exclusively depending on the needed stringency. In this example the obtained combinations dataframe is assigned to "*tab*" object.

```{r}
tab <- Combi(data, signalthr = 450, combithr = 1)
head(tab, n=20)
```

## Sensitivity and specificity

`SE_SP()` function calulates:

- Sensitivity (SE) and specificty (SP) of each combination for each class.
- The number of markers composing each combination (#Markers). 

SE of case class ("A") is calculated dividing the number of positive samples by the total sample of case class (% of positive "A" samples), while case class SP is calculated subtracting SE to 100 (% of negative "A" samples).

SE of control class ("B") is calculated dividing the number of positive samples by the total sample of control class (% of positive "B" samples), while SP is calculated subtracting SE to 100 (% of negative "B" samples).

Thus, the SE of a given combination (capability to find real positives/cases) corresponds to the SE of the case class (in this case "A"), while its SP (capability to exclude real negatives/controls) corresponds to the SP of the control class (in this case "B").
The obtained dataframe with SE, SP and number of markers is assigned to "*mks*" object. 

```{r}
mks <- SE_SP(data, tab)
mks
```
## Selection of combinations

After specifying the case class ("A" in this case), the function `ranked_combs()` ranks the combinations by the Youden index in order to show the combinations with the highest SE (of cases) and SP (of controls) on the top, facilitating the user in the selection of the best ones. The Youden index (J) is calculated in this way:
$$
 J = SE+SP
$$
The user can also set (not mandatory) a minimal value of SE and/or SP that a combination must have to be selected.
In this case the minimal values of SE and SP are set, respectively, to 40 and 80, in order to reproduce both the gold combinations selection reported in [Mazzara et. al 2017](https://www.nature.com/articles/srep45477) and also the tutorial of the web app with default thresholds. The obtained dataframe with ranked combination is assigned to __rmks__ object. 


```{r}
rmks <- ranked_combs(data, mks, case_class = 'A', min_SE = 40, min_SP = 80)
rmks
```

## ROC curves

To allow an objective comparison of combinations, the function `ROC_reports()` applies the Generalised Linear Model (`stats::glm()` with argument `family= binomial`) for each selected one. The resulting predictions are then used to compute ROC curves (with function `pROC::roc()`) and their corresponding metrics which are both returned by the function as a named list object (in this case called __reports__).  The function `ROC_reports()` requires as input:

- The data object ( __data__ ) obtained with `load_data()`.
- The table with combinations and corresponding positive samples counts ( __tab__ ), obtained with `Combi()`.

In addition, the user has to specify the class case, the single markers and/or the combinations of interest with the specific function's arguments.  
In the example below a single marker (Marker1) and 2 combinations (combinations number 11 and 15) were choosen.
```{r}
reports <-ROC_reports(data, markers_table = tab, case_class = 'A',
                      single_markers =c('Marker1'), selected_combinations = c(11,15))
```
The obtained __reports__ object contains 3 items that can be accessed using the `$` operator:

- Plot: a ggplot object with the ROC curves of the selected combinations.
- Metrics: a dataframe with the metrics of the roc curves (AUC, opt. cutoff, etc ...).
- Models: The list of models that have been computed and then used to classify the samples (the equation for each selected combination).

```{r}
reports$Plot
reports$Metrics
reports$Models
```

## Results explanation

For a more in deep discussion on how to interpret the results, this section will be focused on "Combination 11" (combining Marker1, Marker2 and Marker3) which has an optimal cutoff equal to 0.216 (see  teh __CutOff__ column in `reports$Metrics`) .
This is the equation used to compute the predictions:

$$
f(x)=β_0+β_1x_1+β_2x_2+ β_3x_3 +...+β_nx_n
$$


Instead, the predicted probabilities have been calculated with the sigmoid function:

$$
p(x) =  \frac{\mathrm{1} }{\mathrm{1} + e^{-f(x)} }  
$$



The predictions for "Combination 11" have been computed using the coefficients displayed as in `reports$Models` (see previous paragraph):

$$
f(x)=    -17.0128  +  1.5378 *log(Marker1 + 1)  +  0.9176 *log(Marker2 + 1) + 0.5706* log(Marker3 + 1)
$$

Predictions (f(x) values) of 'Combination 11' can be visualized with the following command: 
```{r}
head(predict(reports$Models$`Combination 11`, type='link')) # link = f(x)
head(predict(reports$Models$`Combination 11`, type='link'))  # link = f(x)
```


Prediction probabilities (p(x) values) of 'Combination 11' can be instead visualized by typing: 
```{r}
head(predict(reports$Models$`Combination 11`, type='response')) # response = p(x)
head(predict(reports$Models$`Combination 11`, type='response')) # response = p(x)
```


Finally, the comparison between the prediction probability and the optimal cutoff determines the classification of each sample by following this rule:


$$
C(x) = 
\begin{cases} 
      1 & {p}(x) > opt. cutoff \\
      0 & {p}(x) \leq opt.cutoff 
\end{cases}
$$



Specifically, for "Combination 11":

- Samples with p(x) higher than 0.216 are classified as "positives" (1).
- Samples with p(x) lower or equal to 0.216 are classified as "negatives" (0).

Thus, using 0.216 as cutoff, "Combination 11" is able to classify the samples in the dataset with a SE equal to 95.0%, SP equal to 86.9%, and accuracy equal to 88.8% (see __ROC curves__, `reports$Metrics`).

# Classification of new samples

A new feature of the CombiROC package (not present in the CombiROC Tool Shiny app), offers the possibility to exploit the models obtained with `ROC_reports()` for each selected marker/combination (models that were assigned to `reports$Models`) to directly classify new samples.

The unclassified dataset must be similar to the dataset used for the previous combinatorial analysis (i.e. of the same nature and with the same markers, but obviously _without_ the 'Class' column).

To load datasets with unclassified samples a specific `load_unclassified_data()` function was implemented. This function is analogue to `load_data()` since it loads the same kind of files and it performs the same format checks, with the exception of the _Class_ column which is not present in an unclassified datasets and thus not required.  

For purely dimonstrative purposes, in the following example a "synthetic" unclassified dataset ('data/unclassified_proteomic_data.csv') was used: it was obtained by randomly picking 20 samples from the already classified dataset (the __data__). The loaded unclassified sample is here assinged to the __unc_data__ object. Please note that this dataset has a Patient.ID column which actually allows the identification of the class, but this column is not used in the workflow and has solely labeling purposes.
```{r, eval=FALSE}
unc_data <- load_unclassified_data(data = '../data/demo_unclassified_data.csv', sep = ',')
```
This very same dataset has been included in CombiROC package as an unclassified demo dataset, that can be directly called typing `demo_unclassified_data`. 
```{r}
head(demo_unclassified_data)
```

The prediction of the class can be achieved with `Classify()`: this function applies the models previously calculated on a classified dataset working as training dataset, to the unclassified dataset and classifies the samples accordingly to the prediction probability and optimal cutoff as shown in the __Results explanation__ section.

This `Classify()` function takes as inputs:

- the unclassified dataset containing the new samples to be classified (`unc_data`).
- the list of models `reports$Models` that have been previously computed by `ROC_reports()` (*reports$Models*).
- the list of metrics that have been previously computed by `ROC_reports()` (*reports$Metrics*).

In addition the user can set the labels of the predicted class (setting Positive_class and Negative_class), otherwise they will be 1 for positive samples and 0 for the negative samples by default (see the rule shown in the end of the **Results explanation** section).

The function returns a named list of data.frames (here assigned to *cl_data*), one for each marker/combination contained in the list of models (*reports$Models*), containing the predicted class for each sample.

To visualize a data.frame containing the classification performed by a model corresponding to a given marker/combination ('Combination 11' in the following example) it is sufficient to 
call the data.frame list and specify it.

```{r}
unc_data <- demo_unclassified_data
cl_data <- Classify(unc_data, Models =  reports$Models, Metrics = reports$Metrics, Positive_class = 'A', Negative_class = 'B')
cl_data$`Combination 11`
```

# Additional tips & tricks

The CombiROC package evolved from the [CombiROC Shiny Web app](http://combiroc.eu/) and it is an ongoing project. While the Shiny app is still running, we plan to concentrate any further improvement on the package which will be enriched with new functionalities. In the meantime, here we offer tips on ancillary commands and additional ways to explore the data taking advantage of the long format of the `data_long` object; some of these features maight be natively included or wrapped into new functions in future versions of the CombiROC package.  

## Retrieving composition of combinations

`show_markers()` returns a data frame containing the composition of each combination of interest. It requires as input one or more combinations (only their numbers), and the table with combinations and corresponding positive samples counts (*"tab"*, obtained with `Combi()`).
```{r}
show_markers(selected_combinations =c(11,15), markers_table = tab)
```

## Retrieving combinations containing markers of interest

`combs_with()` returns the combinations containing all the markers of interest. It requires as input one or more single marker, and the table with combinations and corresponding positive samples counts (*"tab"*, obtained with `Combi()`). The list with the combinations containing all the markers is assigned to *"combs_list"* object.
```{r}
combs_list <- combs_with(markers=c('Marker1', 'Marker3'), markers_table = tab)
combs_list
```

## Summary statistics of individual markers

Further markers exploration can be done using other packages' functions such as `group_by()`, `summarize()` and `ggplot()` on the the `data_long` dataframe.
As an example, a few summary statistics can be computed for each marker of both classes, separately, as follow (the libraries `dplyr` and `moments` are needed). Numbers in this table are those behind the box plot obtained with `distr$boxplot` as seen before.

```{r, message=FALSE}
library(dplyr)
library(moments) # needed for skewness() function

data_long %>%
  group_by(Markers, Class) %>%
  summarize(Mean = mean(Values),
            Min = min(Values),
            Max = max(Values),
            Sd = sd(Values),
            CV = sd(Values)/mean(Values),
            First_Quart. = quantile(Values)[2],
            Median = median(Values),
            Third_Quart. = quantile(Values)[4],
            Skewness = skewness(Values))
```

## Plotting of intensities of individual markers

A quick plotting overview of individual marker values can be done with a scatter plot using the library `ggplot2`. Here is an example for the marker "Marker2":

```{r, message=FALSE}
library(dplyr) # needed for the filter() function and %>% operator
library(ggplot2)

myMarker <- "Marker2"

data_long %>%
  filter(Markers == myMarker) %>%
  ggplot(aes(x= Patient.ID, y=Values)) +
  geom_point(aes(color=Class)) +
  labs(title=myMarker, x ="Samples") +
  scale_x_discrete(labels = NULL, breaks = NULL)
```

Back to the [top](#top) of this doc
